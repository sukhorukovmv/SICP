# [Глава 1](../index.md#Глава-1-Построение-абстракций-с-помощью-процедур)

### Упражнение 1.5
Бен Битобор придумал тест для проверки интерпретатора на то, с каким порядком вычислений он работает, аппликативным или нормальным. Бен определяет такие две процедуры:
[Code](../../src/chapter1/1.5.rkt) 
Какое поведение увидит Бен, если интерпретатор использует аппликативный порядок вычислений? Какое поведение он увидит, если интерпретатор использует нормальный порядок вычислений? Объясните ваш ответ. 
####Решение
Аппликативный и нормальный порядки вычисления

«полная подстановка, затем редукция» известен под названием нормальный порядок вычислений (normal-order evaluation)

Пример работы нормального порядка вычисления:
```
     (sum-of-squares (+ 5 1) (* 5 2))
     (+ (square (+ 5 1)) (square (* 5 2))
     (+ (* (+ 5 1) (+ 5 1)) (* (* 5 2) (* 5 2)))
```
за которыми последуют редукции:
```
    (+ (* 6 6) (* 10 10))
    (+ 36 100)
```
вычисление (+ 5 1) и (* 5 2) выполняется здесь по два раза, в соответствии с редукцией выражения

«вычисление аргументов, затем применение процедуры», которое называется аппликативным порядком вычислений (applicative-order evaluation)

Пример работы аппликативного порядка вычисления
```
    (sum-of-squares (+ 5 1) (* 5 2))
    (+ (square 6) (square 10))
    (+ 36 100)
```

В случае аппликативного порядка вычисления мы не войдем в процедуру test так-как не сможем вычислить рекурсивную процедуру p
